# Про цей документ

#### Використання
Цей документ містить відео та статті про різні аспекти програмування на C++. Найкращий спосіб навчитися на них - спробувати їх самостійно, або, у випадку з лекцією, провести власні дослідження та експерименти з цієї теми. 
Та можливо трохи вивчити англійську, це допоможе in the future))

#### Ціль
Цей документ є збіркою високоякісних навчальних матеріалів з c++ як для початківців, так і для мене)

# Що потрібно?
 - [КНИГИ](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#books-c)(https://github.com/hikoezy/CppLearningResourcesUA/tree/main#books-c))
 - [КРАЩІ УРОКИ ПО С++ У YOUTUBE](https://www.youtube.com/@BloganProgramming)
 - [САЙТ ПО ВИВЧЕНУТЬ С++ (MAST HAVE)](https://acode.com.ua/uroki-po-cpp/)
 - [інформаційний ресурс, присвячений проектування програмних систем мовою програмування С++.](https://en.cppreference.com/w/)

# Рівні вивчення інформації (Тип 'MMR' типу рівинь гри - ранк в DOTA2)
 - [C++ NOOB (700MMR)](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#c-%D1%81%D1%82%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D0%B8%D0%B9)
 - [C++ NEWBIE (1500MMR)](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#c-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D0%B8%D0%B9)
 - [C++ MID (3500MMR)](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#%D0%BF%D0%BE%D0%B3%D0%BB%D0%B8%D0%B1%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9-c)
 - [C++ HIGH (6000MMR)](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#stl-c)
 - [C++ TOP TOP (8000+MMOR)](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#вирішення-практичних-завдань-на-c)
 - [GIT](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#git-necessary)
******************************************************
# LEETCODE (По рівням)
[LEETCODE](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#leetcode)
******************************************************
# Співбесіда для джуна
[Співбесіда з C++. запитань для Junior](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#співбесіда-з-c-запитань-для-junior)
******************************************************
# Кращі ресурси (На українській мові)
[Cайтики)](https://github.com/hikoezy/CppLearningResourcesUA/tree/main#for-beginner-на-українській-мові)
******************************************************
# ROADMAP посилання!)
[Дорожня карта для вивчення C++(eng, рус)](https://salmer.github.io/CppDeveloperRoadmap/)

## Якщо хочеш віддячити
#[Click](https://send.monobank.ua/jar/5FVXHU1M7i)














# BOOKS C++
      * Опануй самостійно C++ за 21 день. 7-ме видання (зараз читаю) 153c
      * Грокаем алгоритми (next)
      * Мова програмування C++ (C++11). Лекції і вправи 6-е видання(гарна книга але тільки на мові окупанта і в оригиналі) (next)   
      * Скотт Мейерс | Эффективный и современный С++: 42 рекомендации по использованию C++11 и C++14 - (soon)
      * Райнер Грімм | С++20 в деталях - (soon)
      * Starting Out with C++ from Control Structures to Objects(just english) (soon)
      * Артур О’Двайр | Освоюємо C++17 STL - (soon)
      * Чистый Код. Создание, анализ и рефакторинг - (soon)    
      * The Object-Oriented Thought Process (just english) in order to know OOP deeply - (soon)


  # [C++ Стартовий]
      * Володіти основами мови програмування С++
      * Розуміти, як влаштована пам'ять комп'ютера та як у ній зберігаються дані
      * Працювати зі змінними, константами, проводити арифметичні операції
      * Працювати з різними типами даних, виконувати їх перетворення
      * Застосовувати умовні та логічні оператори
      * Використовувати цикли та функції в С++
      * Розуміти покажчики, працювати з масивами, рядками
      * Розбиратися у просторі імен та основних директивах препроцесора
        
  # [C++ Базовий]
       * Розуміти принципи ООП та застосовувати їх на практиці, використовуючи мову С++
       * Застосовувати узагальнене програмування
       * Використовувати винятки
       * Працювати з шаблонами С++
       * Розуміти та застосовувати "розумні" покажчики
 
  # [Поглиблений C++]      
       * Застосовувати принципи автоматичного виведення типів С++
       * Працювати зі стандартною бібліотекою шаблонів, використовувати функтори
       * Ефективно використовувати стандартні контейнери та алгоритми, а також створювати свої алокатори за необхідності
       * Використовувати паралельне програмування для прискорення виконання програм
       * Розбиратися в семантиці переміщення та прямої передачі
       * Розбиратися в принципах мета-програмування С++
       * Знати основи стандартів Стандарти C++11, C++14, C++17, C++20;

  #  [STL C++]    
       * Розуміти базові принципи влаштування контейнерів із бібліотеки STL та принципи роботи з ними у мові C++.
       * Розуміти критерії оцінки складності алгоритмів. Навчіться виконувати таку оцінку практично.
       * Розуміти принципи влаштування у C++ таких базових структур даних, як стек, черга, однозв'язковий і двозв'язний список, бінарне дерево.
       * Розрізняти види дерев та основні проблеми використання структури даних, бінарне дерево.
       * Розуміти і вміти застосовувати практично різні операції з контейнерами (створення, копіювання, видалення, привласнення тощо.), і навіть оцінювати їх ефективність.
       * Розуміти принципи влаштування асоціативних контейнерів, механіку роботи асоціативних контейнерів, вміти застосовувати Set та Map контейнери та виконувати над ними різні операції.
       * Застосовувати методи прямого доступу до елементів контейнерів, використовувати спеціальні операції для роботи з ітераторами, а також для вставки та видалення елементів контейнера, використовувати адаптери ітераторів та ітератори користувача.
       * Розуміти принципи та вміти застосовувати такі алгоритми, як: немодифікуючі та модифікуючі, алгоритми видалення, перестановочні алгоритми та алгоритми сортування.
       * Розуміти принципи роботи з контейнерними адаптерами, а також застосовувати практично лямбда-функції та функціональні об'єкти.

  #  [Вирішення практичних завдань на C++

       * Вирішувати практичні завдання на С++, використовуючи найкращі практики, застосовуючи шаблони проектування Банди чотирьох та принципи SOLID.
       * Реалізувати базову архітектуру ігрової програми на основі шаблону Спостерігач.
       * Проектувати структуру ігрового циклу з урахуванням потоків повідомлень.
       * Розуміти базові принципи розробки інтерфейсу користувача і застосовувати їх на практиці.
       * Розуміти роль штучного інтелекту в іграх та основні підходи до реалізації ігрового штучного інтелекту. Зокрема, розглядається повний перебір із метрикою.
       * Застосовувати різні текстові формати для прискорення роботи програми.
       * Розуміти роль тестування та вміти застосовувати юніт-тести у процесі практичної розробки програми.
       * Вміти застосовувати концепцію розробки через тестування.
       * Розуміти основні теоретичні підходи до оптимізації додатку в С++ та вміти застосовувати їх на практиці у своєму додатку.

  # [GIT (necessary)]      

       * Встановлювати та налаштовувати Git.
       * Виконувати додавання файлів до системи контролю версій і відстежувати їх зміни.
       * Використовувати .gitignore файл для вказівки того, які файли відстежувати не потрібно.
       * Виконувати коміт – додавати останні зміни файлів коду до сховища.
       * Виконувати навігацію з історії комітів.
       * Виконувати відкат до старіших версій збережених файлів.
       * Створювати репозиторій на GitHub та синхронізувати його з вашим локальним репозиторієм.
       * Створювати цілі окремі гілки збережених змін.
       * Виконувати перемикання між різними гілками.
       * Видаляти, виконувати злиття різних гілок коммітів та вирішувати можливі конфлікти таких злиттів.


  
    

 # [LEETCODE]


#### Noob level
    розв'язуваних завдань на цьому рівні - Easy - Так, у заголовку написано, що їх 5, але я виділив цей рівень, тому що це був мій рівень спочатку, і думаю рівень багатьох, хто в житті не робив такі завдання.
    На цьому рівні ти не можеш розв'язати найпершу і найпопулярнішу задачу на LeetCode - Two Sum будь-якими способами, брут форс, оптимально, неважливо.
    Як пройти на наступний рівень
    Час, який знадобиться вам, щоб перейти на наступний рівень близько 2-5 годин без перерви.
    Усе досить просто, на цьому рівні не потрібно копатися в алгоритмах і структурах даних, треба звикнути до самої платформи, зрозуміти структуру завдань, потрібно прочитати уважно опис задачі, подивитися на приклади, які нам дають (input) і що треба        отримати (output), засамбітити завдання і зрозуміти, що є таке поняття, як edge cases, коли ваше рішення покриває 3 приклади, які вам дали, але інші 60 test cases чомусь валяться.
    Після того як все-таки покрили всі кейси, подивіться рішення інших хлопців у розділі Solutions, які зробили рішення краще, ніж у вас, графіки Runtime і Memory. Поки не треба брати в голову, що це за графіки, все це вивчіть на наступному рівні.
    ********************************************************************************************************************************************************************************************************************************************************
    Вам потрібно розв'язати найпростіші задачі на літкоді, вони схожі на ті, що ви розв'язуєте на роботі :) 
    Де їх знайти? Усе дуже просто. Йдете в Problems -> Easy -> Сортуєте за Acceptance. 
    Дивитеся на перші 20 завдань і розв'язуєте ті, які вам сподобалися, 
    потрібно розв'язати близько 10. Розв'язувати без різниці як, можна найбезглуздішим брутфорсом, у своєму улюбленому середовищі з усіма підказками (але не треба, будь ласка,використовувати ChatGPT:),
    головне - пройти тести та відчути нарешті смак перемоги на літкоді. Найкращий шлях до мотивації це маленькі перемоги, не забувайте про це, поїхали далі!

#### Beginner level
    вирішених завдань 10-50
    100% розв'язуваних завдань на цьому рівні - Easy.
    
    Ви вже можете розв'язати задачки з рівнем Acceptance 70-80% брут форсом в улюбленому середовищі розробки. 
    Розумієте найпростіші структури даних - масиви, словники, зв'язкові списки, черги, стек. Алгоритми ви, звісно, використовуєте, але не заглиблюєтеся, що там всередині, просто набираєте .sort()
    Як пройти на наступний рівень
    Час, який знадобиться вам, щоб перейти на наступний рівень близько 25-40 годин без перерви.
    Щоб пройти на наступний рівень, вам потрібна БАЗА. Ви повинні постраждати на цьому рівні, зате далі буде набагато легше. Вам потрібно взяти ручку і зошит і піти вивчати алгоритми і структури даних. Пропоную почати з вивчення ресурсу neetcode.io,         особливо його RoadMap, бо сам ним користуюся і вважаю найкращим ресурсом, для тих, хто вкочується в алгоритми!
    Вибираєте перший розділ, що ж там? Ах так, масиви. Якщо ви спіймали себе на думці, що так пф-ф, що там масиви, що я там не бачив, то, будь ласка, будь ласка, підіть і почитайте кілька статей, проконспектуйте, помалюйте, забийте в голову, який            вигляд     має цей самий масив, ніколи не буде зайвим освіжити свої знання. Також вивчіть складність вставки, видалення і читання.
    Так, тут уважно. Якщо ви до цього не вивчили докладно, що таке Big O, ідіть, будь ласка, почитайте, проконспектуєте і подивіться кілька відео, як він розраховується, за часом і за пам'яттю. 
    Ок, тепер ви розумієте, що ж це були за графіки Runtime і       
    Memory після вирішення завдань.
    Теорію потрібно закріпити практикою, відкриваєте певний розділ і розв'язуєте всі Easy задачі (якщо хочеться більше, можна перейти на вкладку Practice в NeetCode All). 
    І далі за списком, вивчаєте теорію представлених розділів, закріплюєте практикою      easy завданнями. На цьому етапі немає сенсу спускатися далі рівня Priotity Queue - Graphs - 1DP за роадмапом.

#### Medium level
    Розв'язаних завдань 50-100
    70% розв'язуваних завдань на цьому рівні - Medium, інші 30% - Easy
    
    Ви великий молодець! За моїми підрахунками (Solves problems -> beats) цього рівня досягають <25% усіх програмістів з усього світу.
    Нарешті, ви можете без підглядання розв'язати задачу типу TwoSum брут форсом, і навіть, можливо, оптимально. Ви вже розумієте такі структури даних як дерева, графи, пріоритетна черга, розв'язували задачі різними красивими способами: two pointers, 
    binary search, sliding window тощо. 
    Найімовірніше, ви розв'язуєте більшість задач із підказками, дивлячись на умову, ви розумієте, як розв'язувати задачі, який алгоритм використовувати, яке оптимальне розв'язання потрібне, але не можете написати це в коді.

    ***********************************************************************************************************************************************************************************************************************************************
      На цьому рівні потрібно закінчити з теорією Computer Science, для цього непогано б вивчити більш поглиблено такі алгоритми, як динамічне програмування, рекурсія, backtracking, greedy, алгоритм розділяй і володарюй, алгоритм Флойда, алгоритм Гауса,       більш складні структури даних, різні варіанти дерев, які бувають графи та способи оптимального вирішення таких завдань (DFS, BFS).
      У міру розв'язання задач із роадмапу, ви зіткнетеся з усіма цими алгоритмами і структурами даних. Якщо вам хочеться більше, йдете в NeetCode All і берете завдання звідти. Також у літкоді можна відсортувати задачі за тегами, наприклад, динамічне          програмування, Problems -> Tags.
    
    
  #### Hard level  
      Рівень 3. Аматор. Розв'язаних завдань 100-300
      90% розв'язуваних задач на цьому рівні - Medium, 5% - Easy, 5% - Hard

      Коли у вас 100 розв'язаних задач, ви вже маєте знати всі алгоритми та структури даних, які можуть потрапити до 99% задач на літкоді та, загалом, в алгоритмічних секціях на співбесідах. 
      Рівень написання вашого коду має бути доведений до автоматизму, ви маєте швидко розуміти, яка структура даних, як пройтися, як змінити певний елемент,
      якими способами краще розв'язувати оптимально задачу на ту чи іншу структуру даних, як працює рекурсія, в якому місці ставити покажчики, 
      як визначити міддл із масиву чисел, як крутити дерева зрештою! Ви маєте бути профі в основах Computer Science. Якщо це ще не так, варто зупинитися і пройтися всією теорією, щоб більше не витрачати на неї час, бо далі буде тільки практика.                Прочитати можна, наприклад, цю книжку, вона легко читається, але я б порадив ще почитати інші статті та подивитися кілька відео
      Думаю, на цьому рівні, багато хто кидатиме займатися на літкоді, думаючи, що вони вже можуть пройти співбесіду. 
      Я вважаю, що цього недостатньо, тому що, навіть якщо ви можете розв'язувати якісь задачі без підказок і вкладаєтеся в ліміт часу, на самій співбесіді рівень вашого стресу буде зовсім іншим, і ви, з великою ймовірністю, зафейлите.
      (150 to 300h neet to go the next level!)

   #### PRO level 
       70% розв'язуваних завдань на цьому рівні - Medium, 25% - Hard, 5% - Easy

        Це рівень, де ви вже можете подаватися в FAANG подібні компанії, якщо ви в нижній межі вирішених завдань, ви можете пройти, якщо вам пощастить з інтерв'юером і завдання будуть +- в галузевих стандартах, без хитромудрих edge cases і купи   
        динамічного програмування. Оптимально, якщо ви розв'язали 500-600 завдань, рідко бачив відгуки, хто не проходив алго-секцію з таким рівнем розв'язаних завдань, якщо ви ближче до 1к розв'язаних завдань і не пройшли алго-секцію, вам термінов
        опотрібно підтягнути англійську, з 99% ймовірністю інтерв'юеру не сподобалися ваші комунікативні навички.
        Так, на цьому рівні вам потрібно підтягнути комунікативні навички, якщо інтерв'ю буде англійською, то і її теж. Це дуже важливо, навіть якщо ви розв'яжете задачу, але не пояснюватимете під час розв'язання свої думки, вас завалять.
        (you need to reach this level for about 300h - 500h)

# Співбесіда з C++. запитань для Junior
  ## Junior 
  ##### [Загальні питання]
          1.У чому полягають основні принципи ООП?
          2.Що таке складність алгоритму?
          3.Код працює неправильно. Що робити?
          4.Поясніть такі структури даних, як стек і черга.
          5.Які книги, пов’язані з програмуванням, читали? Чого з них навчились?
          6.Що цікавого знайшли в нових стандартах С++17, С++20?
          7.Що таке таблиця ASCII?
          8.Що таке Unicode?
          9.Що таке патерни проєктування та для чого їх використовують?
          10.Патерни Singleton, Strategy, Template-Method, Decorator?
          11.Для чого потрібні модульні тести?
          12.Яка різниця між модульними та інтеграційними тестами?
          13.Що таке TDD?
   ##### [Метапрограмування]
          14.Що таке шаблонний клас і шаблонна функція?
          15.Що таке конструктори? Які типи знаєте?
          16.Чи може конструктор бути шаблонною функцією?
          17.Чи може віртуальна функція бути шаблонною?
          18.Що таке інстанціація шаблону?
          19.Що таке спеціалізація шаблону? Часткова спеціалізація шаблону?
          20.Розкажіть про імплементацію шаблонних класів у срр-файлі?
          21.Які є правила виведення типу в шаблоні?
          97.Чим відрізняється using від typedef?
          98.Скільки пам’яті займає довільна структура? Що таке вирівнювання об’єкта?
          99.Чому порожня структура займає 1 байт? Яка мінімальна одиниця адресування у С++?
   ##### [Препроцесор і компіляція]
          21.Як проходить процес компіляції срр-файлів у бінарний файл?
          22.Що таке препроцесор?
          23.Як працює препроцесор?
          24.Які знаєте його команди?
          25.Як працює директива include?
          26.Як працює директива define?
          27.Що саме лінкує лінкер?
          28.Що таке оптимізація компілятора?
          29.Що таке прапорці компіляції?
          30.Як захистити хедер від повторного включення?
          31.Що робить директива include?
          32.Як працюють макроси?
   ##### [C++/OOP]
        54.Що таке клас?
        55.Які є основні типи даних у C++?
        56.Що таке інкапсуляція? Як вона реалізується в C++?
        57.Які є вбудовані типи в С++?
        58.Що таке enum?
        59.Як співвідноситься клас і об’єкт?
        60.Яка різниця між структурою і класом?
        61.Різниця між private/protected/public та де вони використовуються?
        62.Які методи класу є стандартними для класу?
        63.Що таке абстрактний клас і навіщо він?
        64.Скільки займає пам’яті об’єкт порожнього класу class A{};?
        65.Що стане з функцією, якщо до неї додати ключове слово static? У контексті члена класу? У контексті методу класу?
        66.Які особливості статичних полів класу?
        67.Яка особливість константних методів-членів класу?
        68.Як змінити поле класу в константному методі класу?
        69.Які методи можна викликати з константних об’єктів?
        70.Що таке купа та стек? Відмінності, принцип роботи.
        71.В чому різниця між вказівником s посиланням?
        72.Для чого потрібен вказівник на функцію? Як його оголосити?
        73.Що буде, якщо забути викликати delete? Коли звільниться та пам’ять?
        74.Що таке розумний вказівник? Які розумні вказівники є в стандартній бібліотеці?
        75.Як працює std::unique_ptr?
        76.Як працює std::shared_ptr?
        77.Розкажіть про константність змінної, посилання, вказівника? Що таке константний вказівник і вказівник на константу? Розмір вказівника в пам’яті?
        78.Розкажіть про передачу аргументів за значенням, посиланням і вказівником?
        79.Розкажіть про порядок обчислення аргументів функції?
        80.Що трапиться, якщо повернути посилання на тимчасовий об’єкт?
        81.Що таке перевантаження функції? Види перевантаження.
        82.Що таке явне та неявне приведення типів у С++? Розкажіть про функції явного приведення типів у C++?
        83.Що таке ініціалізація змінної в if?
        84.Що таке ліниві обчислення в С++?
        85.Розкажіть про цикли for та range-for.
        86.Що робить ключове слово auto? auto-визначення return-типу, аргументів функції?
        87.Чим відрізняються delete та delete[]? Що трапиться, коли викликати delete в об’єкта, створеного через new[]?
        88.Обробка помилок у С++? Які конструкції використовують під час обробки exception?
        89.Чи можна викидати exception з конструктора? Які поля будуть сконструйовані, які поля будуть зруйновані?
        90.Що таке memory leak?
        91.Чи можна викидати exception з деструктора?
        92.Як відловити ділення на 0 в С++?
        93.Як працюють константні методи?
        94.Що таке лямбда-функція у С++? Як отримати доступ до змінних у зовнішній ділянці видимості?
        95.Для чого використовувати namespace, anonymous namespace?
        96.Яе викликати об’єкт з nested namespace?
        97.Як працюють inline-функції? Чи може така функція бути рекурсивною?
        98.Що таке поліморфізм?
        99.Для чого використовується наслідування?
        100.Які бувають типи наслідування?
        101.Для чого використовують віртуальне наслідування?
        102.Як можна розв’язати проблему ромбоподібного наслідування без використання віртуального наслідування?
        103.Що трапиться, якщо клас-спадкоємець передати за значенням у функцію, яка приймає базовий клас?
        104.Що трапиться, якщо успадкуватися від базового класу, який не має віртуального конструктора?
        105.Що трапиться, якщо викликати перевизначену virtual function з конструктора? Чи може конструктор бути віртуальним?
        106.Чи може мати імплементацію pure virtual function? Що трапиться, якщо викликати pure virtual function з конструктора?
        107.Які методи генеруються для класу за замовчуванням? В якому випадку такі методи не будуть генеруватися? Як змусити компілятор додати/видалити ці методи?
        108.Як заборонити успадковувати клас?
        109.Який порядок конструювання та руйнування класів в ієрархії? Порядок ініціалізації полів класу?
        110.Які є способи ініціалізації полів класу?
        111.Чи може деструктор бути віртуальним?
        112.Що робить ключове слово virtual?
        113.Для чого використовують віртуальний деструктор?
        114.Що таке глибоке копіювання?
        115.Що таке віртуальні функції та навіщо вони потрібні?
        116.Як захистити об’єкт від копіювання?
        117.Що таке семантика переміщення?
        100.Що таке SOLID? Що означає кожен з цих принципів?
        101.Розкажіть про патерни проєктування.
        102.Що таке Dependency Injection? Наведіть приклад.
        103.Які переваги та недоліки функціонального підходу?
        104.Що таке принцип RAII?
        105.Що таке принцип DRY?
        106.Що таке принцип KISS?
        107.Які переваги композиції перед успадкуванням?
 ##### [STL/Algorithms]
        118.З чого складається STL?
        119.Які алгоритми застосовували з STL? В чому перевага використання алгоритмів перед власноруч написаними функціями?
        120.Розкажіть про контейнери стандартної бібліотеки vector, list, map, unordered_map.
        121.Які знаєте типи ітераторів? Чим вони відрізняються? В яких контейнерах використовуються?
        122.Яка різниця між std::set, std::map std::unordered_multimap?
        123.Що таке ідіома remove-erase?
        124.Як отримати найменше значення типу?
        125.Яка різниця між std::map та std::hashmap?
        126.Як підрахувати кількість елементів у std::list?
        127.Що таке складність алгоритму та від чого вона залежить?
        128.В чому різниця між vector та list і у яких випадках їх краще використовувати?
        108.Які алгоритми з STL використовували? Яких не вистачає?
        109.Якими особливостями має володіти клас, щоб він був ітератором?
        110.Які бувають ітератори?
        111.Розкажіть про інвалідацію ітераторів.
        112.Як оптимізувати видалення елемента з середини вектора?
        113.Як реалізований vector?
        114.Як реалізований list?
        115.Як розширити STL-контейнери?
        116.Які є алгоритми в STL?
        117.В чому різниця між vector, deque, list, set e STL?
        118.Коли треба використовувати map? Коли — unordered_map? Яка складність пошуку і вставки в цих контейнерах?
        119.Як перевірити, чи є в контейнері елементи? Чому виклик container.size() є поганою практикою?
        120.Що таке exception safety guarantee? Яку exception safety guarantee мають STL-контейнери?
        121.Розкажіть про типи розумних вказівників і підрахунок посилань у них?
        
 ##### [Багатопотоковість]
        129.Що вам відомо про багатопотоковість?
        130.Що спільного і відмінного в процесах і потоках?
        131.Як синхронізувати передачі інформації між потоками?
        132.Яка різниця між м’ютексом і семафором?
        133.Що таке deadlock?
        134.Чи є С++ thread-safe?
        135.Що таке race-condition?
        136.Які уникнути стану гонитви?
        137.Що таке атомарна операція?
        138.Як працювати із std::mutex?
        122.Чи є С++ thread-safe?
        123.У чому різниця між багатопотоковістю та асинхронністю?
        124.Що таке багатопотоковість? Яку функціональність надає С++ для розробки багатопотокових застосунків? Які основні проблеми багатопотокових застосунків?
        125.Як передати інформацію між кількома процесами?
        126.Як синхронізувати між собою кілька процесів?
        127.Які є особливості роботи з shared memory?
        128.Як працює spinlock?
        129.Які ви знаєте особливості використання recursive mutex?
        130.Розкажіть про read-write mutex.
        131.Що таке race-condition? Взаємне блокування? Що таке критична секція?
        132.Які уникнути стану гонитви?
        133.Чим відрізняється м’ютекс від семафора?
        134.Які примітиви синхронізації реалізовані в C++? Переваги lock_guard?
        135.Що трапиться, якщо exception вийде за межі потоку? Які інструменти є для безпечної асинхронності в С++?
        136.Чим відрізняється std::launch::async від std::launch::deferred?
        137.Що таке атомарна операція? std::atomic?
        138.Як працювати з std::conditional_variable?
        139.Як створити потік за допомогою std::thread?
        140.На скільки потоків найкраще розбити задачу? Від чого це залежить?
        141.Як працювати з std::async?
        142.Thread-safe гарантії контейнерів в С++? Чому недолік інтерфейсу front() + pop_fornt()?
 ##### [Патерни проєктування]
        89.Навіщо потрібні патерни? Які типи патернів розрізняють?
        90.Недоліки патерну Singleton? Коли він доречний?
        91.Переваги та недоліки PIMPL?
        92.У чому різниця між патерн-фабрикою та фабричним методом? Коли використовувати який з них?
        93.Що таке патерн Observer?
        94.Як контролювати стан програми? Машину станів? Патерн стан?
        95.Що таке патерн Visitor?
 ##### [Networking]
        139.Що таке сокет?
        140.Які операції можна робити з сокетом?
        141.Яка інформація потрібна, щоб створити сокет?
        142.Які бувають моделі мереж?
        143.Розкажіть про рівні моделі OSI.
        144.Розкажіть про рівні моделі TCP/IP.
        145.Що таке IP-адреса?
        146.Для чого використовується маска підмережі?
        147.Яка різниця між IPv4 та IPv6?
        148.Скільки пам’яті необхідно для зберігання IPv4?
        149.Навіщо порт?
        150.Скільки максимально може бути портів?
        151.Яка різниця між TCP і UDP?
        152.Для чого такий ненадійний UDP-протокол?
##### [OS/Linux]
        153.Що таке менеджер пакетів?
        154.Які бувають менеджери пакетів?
        155.Які бувають дистрибутиви Linux?
        156.Що таке PID?
        157.Для чого використовують файлові дескриптори?
        158.Розкажіть про стандартні файлові дескриптори процесу.
        159.Що таке Pipe?
        160.Що таке Named Pipe?
        161.Що таке UID?
        162.Розкажіть про команди bash.

##### [SCM/CI/CD]
        163.Які є види SCM?
        164.Для чого використовують системи контролю версій?
        165.Які є команди git?
        166.Які етапи під час коміту змін?
        167.Різниця між git fetch і git pull?
        168.Які є етапи вирішення merge conflic

#### [Практичні завдання]
        169.Порахуйте кількість одиниць у довільному числі.
        170.Є структура за типом «однозв’язний список». Напишіть функцію, яка розгортає список. Тобто перший елемент стає останнім, а останній — першим.
        171.Напишіть реалізацію функції int atoi(const char *str); перетворення рядка в число.
        172.Для структури типу однозв’язний список напишіть функцію вставки елемента.
        173.Реалізуйте клас vector.
        174.Реалізуйте бінарний пошук у масиві.
        175.Реалізуйте будь-яке сортування.
        176.Реалізуйте макрос для порівняння двох рядків.
        177.Реалізуйте реверс рядків.
        178.Реалізуйте переведення числа з рядка в int.
        179.Реалізуйте підрахунок слів у реченні.
        180.Реалізуйте підрахунок чисел Фібоначчі.
        181.Знайдіть такі елементи двох масивів, які трапляються тільки в кожному з них. Бажано використовувати STL.
        182.Видаліть з unordered_map елементи, які діляться на 2, і виведіть ключі цих елементів.
        183.Напишіть клас для логування, який міг би логувати до консолі або файлу.
        184.Напишіть функцію для визначення, чи є певний рік високосним.
        185.Напишіть функцію для визначення, чи є певне слово паліндромом.
        186.Напишіть реалізацію патерну Singleton.
        187.Напишіть реалізацію std::vector з операціями: push_back, push_front, pop_back, pop_front, size, clear.
        188.Напишіть рекурсивний пошук значення в дереві бінарного пошуку.
        189.Напишіть функцію, яка перевіряє, чи є дерево збалансованим.
        190.Напишіть функцію для пошуку унікального елемента в масиві.


# Learning sources
## information resources
 - [інформаційний ресурс, присвячений проектування програмних систем мовою програмування С++.](https://en.cppreference.com/w/)
 - [Дорожня карта для вивчення C++(eng, рус)]([https://salmer.github.io/CppDeveloperRoadmap/](https://miro.com/app/board/o9J_lpap34Q=/))
## for beginner (На українській мові)
- [Блоган ⦁ Уроки програмування(там є С++, на мій погляд кращі в ютубі і головне безкоштовні](https://www.youtube.com/@BloganProgramming)
- [acode.com.ua](https://acode.com.ua/uroki-po-cpp/) - soon
- [w3schoolsua.github.io](https://w3schoolsua.github.io/cpp/cpp_getstarted.html#gsc.tab=0) - soon
- [ITVDN платні але там є дуже круті навчальні курси по С++, але на початку краще всеж розгянути варіант с ютубом](https://itvdn.com/ua/specialities/cplspls) - now



